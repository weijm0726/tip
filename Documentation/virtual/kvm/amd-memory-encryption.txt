Secure Memory Encryption (SEV) is a feature found on AMD processors.

SEV is an extension to the AMD-V architecture which supports running multiple
VMs under the control of a hypervisor. When enabled, SEV hardware tags all
code and data with its VM ASID which indicates which VM the data originated
from or is intended for. This tag is kept with the data at all times when
inside the SOC, and prevents that data from being used by anyone other than the
owner. While the tag protects VM data inside the SOC, AES with 128 bit
encryption protects data outside the SOC. When data leaves or enters the SOC,
it is encrypted/decrypted respectively by hardware with a key based on the
associated tag.

Support for SEV can be determined through the CPUID instruction. The CPUID
function 0x8000001f reports information related to SEV:

	0x8000001f[eax]:
		Bit[1] indicates support for SEV

If support for SEV is present, then it can be enabled on specific virtual
machine during the VMRUN instruction by setting the SEV enable bit in VMCB
offset 090h.

SEV uses ASIDs to associated memory encryption key with the guest. The number
of keys that the SEV firmware supports is unlimited. However, there are only
limited number of ASIDs that can be associated with key. In this senario,
SEV-enabled guest must use ASID in a defined subset, while non-SEV guests can
use the remaining ASID range. The range of ASID allowed for SEV-enabled guest
is from 1 to maximum value defined via CPUID 0x8000001f[ecx].


SEV firmware commands
---------------------

The security of SEV is highly dependent on the security of the memory encryption
keys. The SEV firmware that runs within the AMD Secure Processor provides a
secure key management interface to accomplish this. The hypervisor uses this
interface to perform common activities such as encrypting initial guest bios
image for boot, snapshotting, migrating and debugging a guest. For more
informaiton, see SEV key management spec

http://support.amd.com/TechDocs/55766_SEV-KM%20API_Specification.pdf

1. KVM_SEV_LAUNCH_START

Parameters: struct  kvm_sev_launch_start (in/out)
Returns: 0 on success, -negative on error

LAUNCH_START should be called first to create a guest context within the
firmware. The hypervisor provides the firmware with the guestâ€™s security
policy and the public key of the guest owner and session data blob.

The guest policy constrains the use and features activated for the lifetime
of the launched guest, such as disallowing debugging, enabling key sharing,
or turning on other SEV related features.

The provided public key allows the firmware to establish a cryptographic
session with the guest owner to negotiate keys used for attestation.

The session data blob contains the session parameters provided by the
guest owners - this typically includes session nonce, transport encryption
key, policy mac etc.

struct kvm_sev_launch_start {

	/* Guest Hanldle, if zero then FW creates a new handle */
	__u32 handle;

	/* Guest policy */
	__u32 policy;

	/* Guest owner's DH certificate blob */
	__u64 dh_cert_data;
	__u32 dh_cert_length;

	/* Guest owner's Session data blob */
	__u64 session_data;
	__u32 session_length;
};

On success, the 'handle' field contain a new handle.

2. KVM_SEV_LAUNCH_UPDATE_DATA

Parameters (in): struct  kvm_sev_launch_update
Returns: 0 on success, -negative on error

LAUNCH_UPDATE_DATA encrypts the memory region. It also calculates a measurement
of the memory. This measurement is a signature of the memory contents.

struct kvm_sev_launch_update {
	/* address of the data to be encrypted (must be 16-byte aligned) */
	__u64 address;

	/* length of the data to be encrypted (must be 16-byte aligned) */
	__u32 length;
};

3. KVM_SEV_LAUNCH_MEASURE

Parameters (in): struct  kvm_sev_launch_measure
Returns: 0 on success, -negative on error

LAUNCH_MEASURE returns the measurement of the memory region encrypted with
LAUNCH_UPDATE_DATA. The measurement is keyed with the TIK so that the guest
owner can use the measurement to verify the guest was properly launched without
tempering.

struct kvm_sev_launch_measure {
	/* where to copy the measurement blob */
	__u64 address;

	/* length of memory region containing measurement */
	__u32 length;
};

If measurement length is too small, the required length is returned in the
length field and an error is returned.

On success, the measurement blob is copied to the address.

4. KVM_SEV_LAUNCH_FINISH

Returns: 0 on success, -negative on error

LAUNCH_FINISH command finalize the SEV guest launch process.

5. KVM_SEV_GUEST_STATUS

Parameters (out): struct kvm_sev_guest_status
Returns: 0 on success, -negative on error

GUEST_STATUS returns the current SEV state the guest is in and other information

struct kvm_sev_guest_status {

	/* guest hanldle */
	__u32 handle;

	/* guest policy */
	__u32 policy;

	/* guest state  (see below) */
	__u8 state;
};

SEV guest state:

enum {
	/* guest state is not known */
	SEV_STATE_INVALID = 0;
	/* guest is currently being launched */
	SEV_STATE_LAUNCHING.
	/* guest is being launched and ready to accept the ciphertext data */
	SEV_STATE_SECRET,
	/* guest is fully launched and running */
	SEV_STATE_RUNNING,
	/* guest is being migrated in from another SEV machine */
	SEV_STATE_RECEIVING,
	/* guest is getting migrated out another SEV machine */
	SEV_STATE_SENDING
};

6. KVM_SEV_DBG_DECRYPT

DEBUG_DECRYPT command can be used for decrypting a region of guest memory for
the SEV guest debug purposes. Note that since decrypting protected memory allows
the hypervisor to gain access to guest memory, the guest policy must explicitly
allow debugging for this command to work.

Parameters (in): struct kvm_sev_dbg
Returns: 0 on success, -negative on error

struct kvm_sev_dbg {
	/* address of data to decrypt */
	__u64 src_address;

	/* where to copy the decrypted data */
	__u64 dst_address;

	/* length of memory region to decrypt */
	__u32 length;
};

7. KVM_SEV_DBG_ENCRYPT

DEBUG_ENCRYPT command can be used for injecting the data into guest for the SEV
guest debug purposes. Note that since injecting the data into protected memory
allows the hypervisor to modify the guest memory, the guest policy must explicitly
allow debugging for this command to work.

Parameters (in): struct kvm_sev_dbg
Returns: 0 on success, -negative on error

struct kvm_sev_dbg {
	/* address of data to encrypt */
	__u64 src_address;

	/* address of guest memory region */
	__u64 dst_address;

	/* length of memory region to encrypt */
	__u32 length;
};

8. KVM_SEV_SEND_START

Parameters (in): struct kvm_sev_send_start
Returns: 0 on success, -negative on error

SEND_START command is used to export a SEV guest from one platform to another.
It can be used for saving a guest to disk to be resumed later, or it can be
used to migrate a guest across the network to a receiving platform.

struct kvm_sev_send_start {
	/* guest policy */
	__u32 policy;

	/* PDH certificate blob */
	__u64 pdh_cert_data;
	__u32 pdh_cert_length;

	/* platform certificate blob */
	__u64 plat_cert_data;
	__u32 plat_cert_length;

	/* AMD certificae blob */
	__u64 amd_cert_data;
	__u32 amd_cert_length;

	/* session data blob */
	__u64 session_data;
	__u32 session_length;
};

The command uses certificate blobs to establish a new cryptographic context
with the remote platform - the new cryptographic context will be used for
re-encrypting the guest memory before sending it to remote platform.

If length of the certificate blobs are too small, the required length is
returned in the length field and an error is returned.

9. KVM_SEV_SEND_UPDATE_DATA

Parameters (in): struct kvm_sev_send_update_data
Returns: 0 on success, -negative on error

SEND_UPDATE_DATA command is used to re-encrypt the guest memory using the
crytographic context established during SEND_START.

struct kvm_sev_send_update_data {
	/* packet header */
	__u64 hdr_data;
	__u32 hdr_length;

	/* address of guest memory region */
	__u64 guest_address;
	__u32 guest_length;

	/* address of transport buffer */
	__u64 host_address;
	__u32 host_length;
};

If the hdr_length is too small, the required length is returned in the length
field and an error is returned.

10. KVM_SEV_SEND_FINISH

Returns: 0 on success, -negative on error

SEND_FINISH command finalize the SEV guest sending process.

11. KVM_SEV_RECEIVE_START

Parameters (in): struct kvm_sev_receive_start
Returns: 0 on success, -negative on error

RECEIVE_START command is used to import a guest from one platform to another.
It can be used for restoring a guest from disk, or it can be used to migrate
a guest across the network from a sending platform.

struct kvm_sev_receive_start {
	/* guest handle (if zero then new handle will be created) */
	__u32 handle;

	/* guest policy */
	__u32 policy;

	/* PDH certificate data */
	__u64 pdh_cert_data;
	__u32 pdh_cert_length;

	/* Session data */
	__u64 session_data;
	__u32 session_length;
};

The RECEIVE_START command derives the cryptographic context necessary to
re-enrypt the guest memory receieved through the RECEIVE_UPDATE command.

12. KVM_SEV_RECEIVE_UPDATE_DATA

Parameters (in): struct kvm_sev_receive_update_data
Returns: 0 on success, -negative on error

RECEIVE_UPDATE_DATA command is used to re-encrypt the guest memory using the
crytographic context established during RECEIVE_START.

struct kvm_sev_receive_update_data {
	/* packet header receieved from the SEND_UPDATE_DATA command */
	__u64 hdr_data;
	__u32 hdr_length;

	/* address of guest memory region */
	__u64 guest_address;
	__u32 guest_length;

	/* address of transport buffer */
	__u64 host_address;
	__u32 host_length;
};

13. KVM_SEV_RECEIVE_FINISH

Returns: 0 on success, -negative on error

RECEIVE_FINISH command finalize the SEV guest receiving process.
